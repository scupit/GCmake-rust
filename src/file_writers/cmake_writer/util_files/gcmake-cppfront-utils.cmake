# Copy a set of files in a common prefix into another directory, but retain
# directory structure.
function( gcmake_copy_mirrored
  file_list_var
  file_common_prefix
  destination_dir
  should_delete_originals_after
)
  list( LENGTH ${file_list_var} at_least_one_file )

  if( NOT at_least_one_file )
    message( FATAL_ERROR "The variable '${file_list_var}' passed as file_list_var must contain at least one file, but doesn't." )
  endif()

  set( dir_names )
  list( TRANSFORM ${file_list_var}
    REPLACE "${file_common_prefix}" ""
    OUTPUT_VARIABLE relative_file_paths_list
  )

  # Collect all unique relative output directory paths into the 'dir_names' list.
  # These will serve as our "map" keys.
  foreach( relative_path IN LISTS relative_file_paths_list )
    cmake_path( GET relative_path PARENT_PATH relative_dir )

    if( NOT relative_dir IN_LIST dir_names )
      list( APPEND dir_names "${relative_dir}" )
    endif()
  endforeach()
  
  list( LENGTH dir_names num_unique_dirs )
  math( EXPR num_unique_dirs_end "${num_unique_dirs} - 1" OUTPUT_FORMAT DECIMAL )

  if( num_unique_dirs LESS_EQUAL 0 )
    message( FATAL_ERROR "After getting directories from file paths, no directories remained. This should be unreachable." )
  endif()

  # Initialize each map bucket
  foreach( index RANGE 0 ${num_unique_dirs_end} )
    set( dir_files_${index} )
  endforeach()

  # Distribute files into the bucket which matches their relative directory path
  foreach( relative_path IN LISTS relative_file_paths_list )
    cmake_path( GET relative_path PARENT_PATH relative_dir )

    # Guaranteed to be >= 0
    list( FIND dir_names "${relative_dir}" dir_name_index )
    list( APPEND dir_files_${dir_name_index} "${relative_path}" )
  endforeach()

  # For each unique directory path "key", set up a command which
  # copies all files from its matching "bucket" into the structure-preserving
  # destination directory.
  foreach( index RANGE 0 ${num_unique_dirs_end} )
    list( GET dir_names ${index} relative_dir )

    list( TRANSFORM dir_files_${index}
      PREPEND "${file_common_prefix}"
      OUTPUT_VARIABLE files_before_copy
    )

    list( TRANSFORM dir_files_${index}
      PREPEND "${destination_dir}"
      OUTPUT_VARIABLE files_after_copy
    )

    set( full_destination_dir "${destination_dir}/${relative_dir}" )
    string( REGEX REPLACE "/+\$" "" full_destination_dir "${full_destination_dir}" )

    add_custom_command(
      COMMAND ${CMAKE_COMMAND} -E copy_if_different ${files_before_copy} "${full_destination_dir}"
      OUTPUT ${files_after_copy}
      DEPENDS ${files_before_copy}
    )

    if( should_delete_originals_after )
      # The target's name doesn't matter, but it must be unique.
      # Since the each absolute file path subset is both project-specific and unique,
      # we can hash the subset to guarantee that the generated target name won't ever
      # (astronomically low probability) collide with another.
      string( SHA1 dummy_hash "${files_before_copy}")
      string( MAKE_C_IDENTIFIER "${dummy_hash}" hash_ident )
      
      # This only works if it's a custom target instead of a custom command. I don't know why that is.
      add_custom_target( ${PROJECT_NAME}_remove_original_${hash_ident} ALL
        COMMAND ${CMAKE_COMMAND} -E rm ${files_before_copy}
        DEPENDS ${files_after_copy}
        COMMAND_EXPAND_LISTS
      )
    endif()
  endforeach()
endfunction()

function( gcmake_transform_cppfront_files
  cpp2_file_list_var
)
  message( "In files: ${${cpp2_file_list_var}}")

  # Get the list of files which will be generated by cppfront
  list( TRANSFORM ${cpp2_file_list_var}
    REPLACE "\\.cpp2" ".cpp"
    OUTPUT_VARIABLE generated_files_list
  )

  message( "Generated files: ${generated_files_list}")

  set( generated_files_dir "${${PROJECT_BASE_NAME}_GENERATED_SOURCE_ROOT}" )
  set( generated_files_initial_prefix "${${PROJECT_BASE_NAME}_ENTRY_ROOT}")

  message( "generated_files_dir: ${generated_files_dir}" )
  message( "generated_files_initial_prefix: ${generated_files_initial_prefix}")

  # The list of generated files after they are moved to the binary directory. This ensures
  # the source directory doesn't become cluttered. 
  list( TRANSFORM generated_files_list
    # The project's entry file root is its root directory (not the root project, but the root directory of the
    # current project). This is the highest directory where files in this project level can appear.
    REPLACE "^${generated_files_initial_prefix}" "${generated_files_dir}"
    OUTPUT_VARIABLE out_files_list
  )

  message( "out files: ${out_files_list}\n")

  add_custom_command(
    # The cppfront::compiler target exists here because this is built as a subdirectory of the
    # main project, which always
    COMMAND cppfront::compiler ${${cpp2_file_list_var}}
    # Gives CMake knowledge of the cpp files to be generated so that targets
    # can use them even if they haven't been created yet.
    OUTPUT ${generated_files_list}

    # This command depends on the contents of the .cpp2 files, and
    # should be re-run every time a .cpp2 file is changed.
    DEPENDS ${${cpp2_file_list_var}}
  )

  gcmake_copy_mirrored(
    generated_files_list
    "${generated_files_initial_prefix}"
    "${generated_files_dir}"
    TRUE
  )
endfunction()